<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Noche Pixel – v9</title>
  <style>
    :root { --radius: 14px; }
    * { box-sizing: border-box }
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { background:#0b1120; font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; }
    #scene { position:fixed; inset:0; width:100vw; height:100vh; display:block; }
    .spotify{
      position:fixed; right:max(12px, env(safe-area-inset-right)); bottom:max(12px, env(safe-area-inset-bottom));
      border-radius:var(--radius); overflow:hidden; box-shadow:0 18px 60px rgba(0,0,0,.55); background:#0f172a; z-index:10;
    }
    .spotify iframe{ display:block; border:0; width:clamp(250px,24vw,340px); height:clamp(260px,42vh,420px); }
    @media (max-width:640px){ .spotify{ right:50%; transform:translateX(50%); top:max(10px, env(safe-area-inset-top)); bottom:auto; } }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <div class="spotify">
    <iframe src="https://open.spotify.com/embed/playlist/5I9ZvE52QlLdc8SdU1WCVP" allow="encrypted-media" loading="lazy" title="Spotify"></iframe>
  </div>

<script>
(function(){
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');
  
  let PX = 2;
  let windowFrame = {x: 0, y: 0, w: 0, h: 0};
  
  // Redimensionar canvas
  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    
    PX = Math.max(2, Math.floor(Math.min(w, h) / 360));
    
    console.log('Canvas resized:', w, h, 'PX:', PX);
  }
  
  // Datos de la escena
  const stars = [];
  for(let i = 0; i < 180; i++) {
    stars.push({
      x: Math.random(),
      y: Math.random() * 0.6,
      r: Math.random() * 1.7 + 0.5,
      phase: Math.random() * Math.PI * 2,
      alpha: 0.5 + Math.random() * 0.5
    });
  }
  
  const cityLayers = [
    {color:'#1a2544', speed:0.18, buildings:[]},
    {color:'#212c58', speed:0.32, buildings:[]},
    {color:'#2a3772', speed:0.52, buildings:[]}
  ];
  
  function buildCity() {
    const W = canvas.width;
    const H = canvas.height;
    const baseCounts = [16, 12, 9];
    
    cityLayers.forEach((layer, i) => {
      layer.buildings = [];
      const count = Math.round(baseCounts[i] * (W / 1200 + 0.4));
      
      for(let k = 0; k < count; k++) {
        const bw = Math.floor((32 + Math.random() * 90) * (PX / 2));
        const bh = Math.floor((80 + Math.random() * 240) * (PX / 2));
        const x = Math.floor(Math.random() * (W + 200)) - 100;
        const y = H - bh - (50 + i * 16) * PX;
        
        layer.buildings.push({x, y, w: bw, h: bh});
      }
    });
  }
  
  // Cometa
  const comet = {x: 0, y: 0, active: false, trail: [], speed: 10};
  
  function triggerComet() {
    const f = windowFrame;
    comet.active = true;
    comet.trail = [];
    comet.x = f.x + f.w + 60;
    comet.y = f.y + Math.random() * f.h * 0.45 + 8 * PX;
  }
  
  // Sprites pixelados
  function drawPixelSprite(grid, ox, oy, scale = 1) {
    const s = PX * scale;
    
    // Dibujar píxeles
    for(let y = 0; y < grid.length; y++) {
      for(let x = 0; x < grid[0].length; x++) {
        const color = grid[y][x];
        if(!color) continue;
        
        ctx.fillStyle = color;
        ctx.fillRect(ox + x * s, oy + y * s, s, s);
      }
    }
    
    // Contorno negro
    ctx.fillStyle = '#000';
    for(let y = 0; y < grid.length; y++) {
      for(let x = 0; x < grid[0].length; x++) {
        if(!grid[y][x]) continue;
        
        const px = ox + x * s;
        const py = oy + y * s;
        
        ctx.fillRect(px, py, s, 1);
        ctx.fillRect(px, py, 1, s);
        ctx.fillRect(px + s - 1, py, 1, s);
        ctx.fillRect(px, py + s - 1, s, 1);
      }
    }
  }
  
  // Crear pareja
  function createCouple(breathe = 0, heartBeat = 0) {
    const w = 42, h = 34;
    const grid = Array.from({length: h}, () => Array(w).fill(null));
    
    function setPixel(x, y, width, height, color) {
      for(let j = 0; j < height; j++) {
        for(let i = 0; i < width; i++) {
          if(y + j >= 0 && y + j < h && x + i >= 0 && x + i < w) {
            grid[y + j][x + i] = color;
          }
        }
      }
    }
    
    const skin1 = '#f0bfa1';
    const skin2 = '#d4a574';
    const hairDark = '#3d2817';
    const hairBrown = '#8b4513';
    const hoodie1 = '#1e72e6';
    const hoodie1Dark = '#1555ad';
    const sweater2 = '#e74c3c';
    const sweater2Dark = '#c0392b';
    const jeans = '#2c3e50';
    const skirt = '#f39c12';
    const shoe = '#2c2c2c';
    
    const breatheOffset = Math.round(Math.sin(breathe) * 0.8);
    const heartOffset = Math.round(Math.sin(heartBeat * 3) * 0.3);
    
    // Sombras románticas en el suelo
    setPixel(4, 32, 34, 1, 'rgba(0,0,0,.2)');
    
    // === PERSONA 1 (IZQUIERDA) - HOMBRE ===
    
    // Cabeza (ligeramente inclinada hacia ella)
    setPixel(6, 6, 4, 4, skin1);
    setPixel(7, 5, 2, 1, skin1);
    
    // Pelo
    setPixel(5, 4, 6, 3, hairDark);
    setPixel(6, 3, 4, 1, hairDark);
    
    // Ojos (mirándola con amor) y sonrisa
    setPixel(6, 6, 1, 1, '#000');
    setPixel(9, 6, 1, 1, '#000');
    setPixel(7, 8, 2, 1, '#ff6b9d'); // sonrisa rosa
    
    // Cuerpo - Hoodie azul
    setPixel(4, 10 + breatheOffset, 8, 12, hoodie1);
    setPixel(4, 14 + breatheOffset, 8, 1, hoodie1Dark);
    setPixel(4, 18 + breatheOffset, 8, 2, hoodie1Dark);
    
    // Brazos (abrazo protector)
    setPixel(2, 12 + breatheOffset, 2, 6, hoodie1);
    setPixel(12, 12 + breatheOffset, 3, 4, hoodie1); // brazo que la abraza más fuerte
    
    // Pantalón
    setPixel(5, 22 + breatheOffset, 6, 8, jeans);
    setPixel(5, 24 + breatheOffset, 6, 1, '#34495e');
    
    // Zapatos
    setPixel(4, 30 + breatheOffset, 3, 2, shoe);
    setPixel(9, 30 + breatheOffset, 3, 2, shoe);
    
    // === PERSONA 2 (DERECHA) - MUJER ===
    
    // Cabeza (recostada suavemente en su hombro)
    setPixel(17, 8 + heartOffset, 4, 4, skin2);
    setPixel(18, 7 + heartOffset, 2, 1, skin2);
    
    // Pelo largo y romántico
    setPixel(15, 6 + heartOffset, 8, 4, hairBrown);
    setPixel(16, 4 + heartOffset, 6, 2, hairBrown);
    setPixel(14, 10 + heartOffset, 2, 4, hairBrown); // pelo que fluye
    setPixel(23, 10 + heartOffset, 2, 4, hairBrown);
    
    // Ojos cerrados (feliz) y sonrisa dulce
    setPixel(18, 8 + heartOffset, 1, 1, '#ff69b4'); // ojo cerrado rosa
    setPixel(21, 8 + heartOffset, 1, 1, '#ff69b4');
    setPixel(19, 10 + heartOffset, 2, 1, '#ff1493'); // sonrisa más dulce
    
    // Cuerpo - Suéter rojo acurrucado
    setPixel(15, 12 + breatheOffset + heartOffset, 9, 10, sweater2);
    setPixel(15, 16 + breatheOffset + heartOffset, 9, 1, sweater2Dark);
    
    // Brazos (abrazo cariñoso)
    setPixel(13, 14 + breatheOffset, 2, 4, sweater2); // abraza su cintura
    setPixel(24, 14 + breatheOffset, 2, 5, sweater2);
    
    // Falda
    setPixel(14, 22 + breatheOffset, 11, 6, skirt);
    setPixel(14, 24 + breatheOffset, 11, 1, '#e67e22');
    
    // Piernas
    setPixel(16, 28 + breatheOffset, 2, 2, skin2);
    setPixel(22, 28 + breatheOffset, 2, 2, skin2);
    
    // Zapatos
    setPixel(15, 30 + breatheOffset, 3, 2, '#8e44ad);
    setPixel(22, 30 + breatheOffset, 3, 2, '#8e44ad');
    
    // === DETALLES ROMÁNTICOS ===
    
    // Abrazo más íntimo
    setPixel(13, 15 + breatheOffset, 3, 3, hoodie1); // su brazo alrededor de ella
    setPixel(11, 12 + breatheOffset, 3, 2, sweater2); // ella se acurruca en él
    
    // Corazoncitos flotantes (aparecen y desaparecen)
    if(Math.sin(heartBeat * 2) > 0.3) {
      setPixel(25, 6, 1, 1, '#ff1493');
      setPixel(26, 5, 1, 1, '#ff1493');
      setPixel(27, 6, 1, 1, '#ff1493');
      setPixel(26, 7, 1, 1, '#ff1493');
    }
    
    if(Math.sin(heartBeat * 2.3) > 0.5) {
      setPixel(2, 8, 1, 1, '#ff69b4');
      setPixel(3, 7, 1, 1, '#ff69b4');
      setPixel(4, 8, 1, 1, '#ff69b4');
      setPixel(3, 9, 1, 1, '#ff69b4');
    }
    
    return grid;
  }
  
  // Crear perro
  function createDog(frame = 0) {
    const w = 24, h = 16;
    const grid = Array.from({length: h}, () => Array(w).fill(null));
    
    function setPixel(x, y, width, height, color) {
      for(let j = 0; j < height; j++) {
        for(let i = 0; i < width; i++) {
          if(y + j >= 0 && y + j < h && x + i >= 0 && x + i < w) {
            grid[y + j][x + i] = color;
          }
        }
      }
    }
    
    const white = '#fff';
    const gray = '#e8e8e8';
    
    // Cuerpo
    setPixel(6, 6, 12, 6, white);
    setPixel(3, 4, 5, 6, white); // cabeza
    setPixel(8, 4, 2, 2, white); // orejas
    
    // Cola (animada)
    if(frame === 0) {
      setPixel(18, 6, 3, 2, white);
      setPixel(21, 5, 1, 2, gray);
    } else {
      setPixel(18, 7, 3, 2, white);
      setPixel(21, 8, 1, 2, gray);
    }
    
    // Patas
    setPixel(8, 12, 2, 3, gray);
    setPixel(14, 12, 2, 3, gray);
    
    // Ojos
    setPixel(5, 6, 1, 1, '#333');
    setPixel(4, 8, 1, 1, '#333');
    
    return grid;
  }
  
  // Dibujar habitación
  function drawRoom() {
    const W = canvas.width;
    const H = canvas.height;
    
    // Fondo degradado de la pared
    const gradient = ctx.createLinearGradient(0, 0, 0, H);
    gradient.addColorStop(0, '#0b1228');
    gradient.addColorStop(1, '#0a1022');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, W, H);
    
    // Calcular posición y tamaño de ventana
    const marginX = Math.max(16 * PX, W * 0.06);
    const marginY = Math.max(12 * PX, H * 0.06);
    const frameW = Math.max(320, W - marginX * 2);
    const frameH = Math.max(220, Math.min(H * 0.64, H - marginY * 2));
    const frameX = (W - frameW) / 2;
    const frameY = marginY;
    
    // Hueco de la ventana (cielo)
    ctx.fillStyle = '#071022';
    ctx.fillRect(frameX, frameY, frameW, frameH);
    
    // Marco de madera
    ctx.lineWidth = 10 * PX;
    ctx.strokeStyle = '#6a3c1f';
    ctx.strokeRect(frameX + 5 * PX, frameY + 5 * PX, frameW - 10 * PX, frameH - 10 * PX);
    
    ctx.lineWidth = 6 * PX;
    ctx.strokeStyle = 'rgba(255,180,120,.08)';
    ctx.strokeRect(frameX + 8 * PX, frameY + 8 * PX, frameW - 16 * PX, frameH - 16 * PX);
    
    // División central de la ventana
    ctx.fillStyle = '#6a3c1f';
    ctx.fillRect(frameX + frameW/2 - 2 * PX, frameY + 2 * PX, 4 * PX, frameH - 4 * PX);
    
    // Repisa de la ventana
    ctx.fillStyle = '#151b2d';
    ctx.fillRect(frameX - 8 * PX, frameY + frameH, frameW + 16 * PX, 6 * PX);
    ctx.fillStyle = '#0f1526';
    ctx.fillRect(frameX - 8 * PX, frameY + frameH + 6 * PX, frameW + 16 * PX, 6 * PX);
    
    // Piso
    ctx.fillStyle = '#0c1222';
    ctx.fillRect(0, frameY + frameH + 12 * PX, W, H - (frameY + frameH + 12 * PX));
    
    // Actualizar frame de ventana para otras funciones
    windowFrame = {x: frameX, y: frameY, w: frameW, h: frameH};
    
    // Indicador discreto
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '10px monospace';
    ctx.fillText('v9 running', 10, 20);
  }
  
  // Dibujar ciudad y cielo
  function drawCityAndSky(time) {
    const {x, y, w, h} = windowFrame;
    
    // Clip al área de la ventana
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip();
    
    // Cielo degradado más romántico
    const skyGradient = ctx.createLinearGradient(0, y, 0, y + h);
    skyGradient.addColorStop(0, '#1a0933'); // Púrpura romántico
    skyGradient.addColorStop(0.3, '#09133a');
    skyGradient.addColorStop(1, '#030815');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(x, y, w, h);
    
    // Estrellas titilantes más románticas
    for(const star of stars) {
      const twinkle = 0.4 + 0.6 * Math.sin(time / 700 + star.phase);
      ctx.globalAlpha = star.alpha * twinkle;
      
      // Algunas estrellas son rosadas para ambiente romántico
      if(star.r > 1.5) {
        ctx.fillStyle = '#ffb3d9';
      } else {
        ctx.fillStyle = '#fff';
      }
      
      ctx.beginPath();
      ctx.arc(x + star.x * w, y + star.y * h, star.r, 0, Math.PI * 2);
      ctx.fill();
      
      // Brillo extra para estrellas grandes
      if(star.r > 1.3) {
        ctx.globalAlpha = star.alpha * twinkle * 0.3;
        ctx.beginPath();
        ctx.arc(x + star.x * w, y + star.y * h, star.r * 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
    
    // Luna romántica
    const moonX = x + w * 0.8;
    const moonY = y + h * 0.15;
    const moonGrad = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, 25);
    moonGrad.addColorStop(0, 'rgba(255,240,200,0.9)');
    moonGrad.addColorStop(0.7, 'rgba(255,240,200,0.4)');
    moonGrad.addColorStop(1, 'rgba(255,240,200,0)');
    ctx.fillStyle = moonGrad;
    ctx.beginPath();
    ctx.arc(moonX, moonY, 25, 0, Math.PI * 2);
    ctx.fill();
    
    // Centro de la luna
    ctx.fillStyle = '#fff3cc';
    ctx.beginPath();
    ctx.arc(moonX, moonY, 12, 0, Math.PI * 2);
    ctx.fill();
    
    // Capas de edificios
    cityLayers.forEach(layer => {
      for(const building of layer.buildings) {
        const shift = (time * layer.speed) % (w + 200);
        const bx = x + ((building.x - shift + w + 200) % (w + 200)) - 100;
        const by = y + (building.y - (canvas.height - h));
        
        ctx.fillStyle = layer.color;
        ctx.fillRect(bx, by, building.w, building.h);
        
        // Ventanas románticas con luz cálida
        if(Math.random() > 0.7) {
          const windowCount = Math.floor(building.w / (8 * PX));
          for(let i = 0; i < windowCount; i++) {
            if(Math.random() > 0.6) {
              ctx.fillStyle = '#ffeb99';
              ctx.fillRect(bx + i * 8 * PX + 2 * PX, by + 4 * PX, 3 * PX, 3 * PX);
            }
          }
        }
      }
    });
    
    // Cometa más romántico
    if(comet.active) {
      comet.trail.push({x: comet.x, y: comet.y});
      if(comet.trail.length > 20) comet.trail.shift();
      
      // Trail más largo y romántico
      for(let i = 0; i < comet.trail.length; i++) {
        const pos = comet.trail[i];
        ctx.globalAlpha = i / comet.trail.length * 0.8;
        
        const rad = 3 * PX;
        const grad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, rad * 4);
        grad.addColorStop(0, 'rgba(255,192,203,1)'); // Rosa romántico
        grad.addColorStop(0.5, 'rgba(255,255,210,0.8)');
        grad.addColorStop(1, 'rgba(255,255,210,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, rad * 4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.globalAlpha = 1;
      
      // Cometa principal con colores románticos
      const rad = 5 * PX;
      const grad = ctx.createRadialGradient(comet.x, comet.y, 0, comet.x, comet.y, rad * 3);
      grad.addColorStop(0, 'rgba(255,192,203,1)');
      grad.addColorStop(0.3, 'rgba(255,255,210,0.9)');
      grad.addColorStop(1, 'rgba(255,255,210,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(comet.x, comet.y, rad * 3, 0, Math.PI * 2);
      ctx.fill();
      
      comet.x -= comet.speed * 0.8; // Más lento y elegante
      comet.y += comet.speed * 0.15;
      
      if(comet.x < x - 100 || comet.y > y + h + 60) {
        comet.active = false;
        comet.trail = [];
      }
    } else if(Math.random() < 0.002) { // Menos frecuente para ser más especial
      triggerComet();
    }
    
    ctx.restore();
  }
  
  // Loop principal
  let dogFrame = 0;
  let lastDogSwitch = performance.now();
  
  function animate(time) {
    // Limpiar canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Dibujar escena
    drawRoom();
    drawCityAndSky(time);
    
    // Dibujar pareja
    const couple = createCouple((time / 1000) % (2 * Math.PI), (time / 800) % (2 * Math.PI));
    const coupleW = 84 * PX; // Ajustado para el nuevo ancho más romántico
    const coupleH = 68 * PX;
    const coupleX = windowFrame.x + windowFrame.w / 2 - coupleW / 2;
    const coupleY = windowFrame.y + windowFrame.h - coupleH / 2 + 8 * PX;
    
    // Animar perro (ANTES para que quede detrás)
    if(time - lastDogSwitch > 450) {
      dogFrame = (dogFrame + 1) % 2;
      lastDogSwitch = time;
    }
    
    const dog = createDog(dogFrame);
    const dogX = windowFrame.x + windowFrame.w / 2 - 12 * PX;
    const dogY = coupleY + 40 * PX; // Más abajo para que no tape
    drawPixelSprite(dog, dogX, dogY, 2);
    
    // Dibujar pareja encima del perro
    drawPixelSprite(couple, coupleX, coupleY, 2);
    
    requestAnimationFrame(animate);
  }
  
  // Event listeners
  window.addEventListener('resize', () => {
    resize();
    buildCity();
  });
  
  canvas.addEventListener('click', triggerComet);
  canvas.addEventListener('touchstart', (e) => {
    triggerComet();
    e.preventDefault();
  });
  
  // Inicializar
  resize();
  buildCity();
  animate(0);
  
  console.log('Noche Pixel v9 iniciada correctamente');
})();
</script>
</body>
</html>
